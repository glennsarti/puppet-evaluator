Examples('resource evaluator',
  Let('resourceType', @(SRC)),
  type MyRes = Resource {
    attributes => {
      ensure => { type => Optional[Enum[present,absent,file,directory,link]], value => undef }
    }
  }
  |-SRC

  Examples('when evaluating nodes',
    Example('evaluates in the right order',
      Given(@(SRC)),
        notice($x) <- $x = 'hello'
        |-SRC
      Evaluates_with(Notice('hello'))),

    Example('evaluates to value of last node when last expression is a relational operator',
      Given(@(SRC)),
        $y = "$x wonderful" <- $x = 'hello' -> "$y world"
        |-SRC
      Evaluates_to('hello wonderful world')),

    Example('evaluates to array with values of last nodes when last expression is a relational operator',
      Given(@(SRC)),
        $y = "$x wonderful" <- $x = 'hello' -> ["$y world", "$y planet"]
        |-SRC
      Evaluates_to(['hello wonderful world', 'hello wonderful planet'])),

    Example('makes previous nodes result available as ResultSet in $pnr',
      Given(@(SRC)),
        $pnr['a'].value <- Result('a', 'hello')
        |-SRC
      Evaluates_to('hello')),

    Example('makes previous nodes results available as ResultSet in $pnr',
      Given(@(SRC)),
        "${pnr['a'].value} ${pnr['b'].value}" <- [ Result('a', 'hello'),  Result('b', 'world') ]
        |-SRC
      Evaluates_to('hello world')),

    Example('propagate errors from previous nodes',
      Given(@(SRC)),
        $pnr.ok <- [ Result('a', 'hello'),  Result('b', Error('oops')) ]
        |-SRC
      Evaluates_to(false)),
  ),

  Examples('when creating resources',
    Example('returns array of objects',
      Given(Format(@(SRC), Get('resourceType'))),
        %s
        String(myres { '/foo/bar': ensure => present })
        |-SRC
      Evaluates_to(`[MyRes('title' => '/foo/bar', 'ensure' => 'present')]`)),

    Example('creates one object per title',
      Given(Format(@(SRC), Get('resourceType'))),
        %s
        String(myres { ['/foo/bar', '/foo/baz']: ensure => present })
        |-SRC
      Evaluates_to(`[MyRes('title' => '/foo/bar', 'ensure' => 'present'), MyRes('title' => '/foo/baz', 'ensure' => 'present')]`)),

    Example('creates one object per body',
      Given(Format(@(SRC), Get('resourceType'))),
        %s
        String(myres { '/foo/bar': ensure => present; '/foo/baz': ensure => absent })
        |-SRC
      Evaluates_to(`[MyRes('title' => '/foo/bar', 'ensure' => 'present'), MyRes('title' => '/foo/baz', 'ensure' => 'absent')]`)),

    Example('creates one object per title and body',
      Given(Format(@(SRC), Get('resourceType'))),
        %s
        myres {
          ['/foo/bar', '/foo/baz']:
            ensure => present;
          ['/fu/bar', '/fu/baz']:
            ensure => absent
        }
        get_resources().map |$k, $v| { [ $v.title, $v.ensure ] }
        |-SRC
      Evaluates_to([
        [ '/foo/bar', 'present' ],
        [ '/foo/baz', 'present' ],
        [ '/fu/bar', 'absent' ],
        [ '/fu/baz', 'absent' ],
        ])),

    Example('same type and title cannot be instantiated twice',
      Given(Format(@(SRC), Get('resourceType'))),
        %s
        myres { '/foo/bar': ensure => present }
        myres { '/foo/bar': ensure => file }
        |-SRC
      Evaluates_with(Issue(EVAL_DUPLICATE_RESOURCE, ref => 'myres[/foo/bar]', 'previous_location' => '(line: 6, column: 9)'))),

    Example('can be ordered using ->',
      Given(Format(@(SRC), Get('resourceType'))),
        %s
        myres { '/foo/bar': } ->
        myres { '/foo/baz': } ->
        get_edges(MyRes['/foo/bar']).map |$e| { [$e.from.resources.keys, $e.to.resources.keys, $e.subscribe] }
        |-SRC
      Evaluates_to([[['myres[/foo/bar]'], ['myres[/foo/baz]'], false]])),

    Example('can be ordered using <-',
      Given(Format(@(SRC), Get('resourceType'))),
        %s
        myres { '/foo/bar': } <-
        myres { '/foo/baz': } ->
        get_edges(MyRes['/foo/baz']).map |$e| { [$e.from.resources.keys, $e.to.resources.keys, $e.subscribe] }
        |-SRC
      Evaluates_to([[['myres[/foo/baz]'], ['myres[/foo/bar]'], false]])),

    Example('can be ordered using ~>',
      Given(Format(@(SRC), Get('resourceType'))),
        %s
        myres { '/foo/bar': } ~>
        myres { '/foo/baz': } ->
        get_edges(MyRes['/foo/bar']).map |$e| { [$e.from.resources.keys, $e.to.resources.keys, $e.subscribe] }
        |-SRC
      Evaluates_to([[['myres[/foo/bar]'], ['myres[/foo/baz]'], true]])),

    Example('resources are applied',
      Given(Format(@(SRC), Get('resourceType'))),
        %s
        myres { '/foo/bar': } ->
        myres { '/foo/baz': }
        |-SRC
      Evaluates_with(Notice('Applying myres[/foo/bar]', 'Applying myres[/foo/baz]'))),

    Example('can be ordered using <~"',
      Given(Format(@(SRC), Get('resourceType'))),
        %s
        myres { '/foo/bar': } <~
        myres { '/foo/baz': } ->
        get_edges(MyRes['/foo/baz']).map |$e| { [$e.from.resources.keys, $e.to.resources.keys, $e.subscribe] }
        |-SRC
      Evaluates_to([[['myres[/foo/baz]'], ['myres[/foo/bar]'], true]])),

    Example('arrays can be ordered using ->"',
      Given(Format(@(SRC), Get('resourceType'))),
        %s
        [ myres { '/a/a': }, myres { '/a/b': }, myres { '/a/c': } ] ->
        [ myres { '/b/a': }, myres { '/b/b': }, myres { '/b/c': } ] ->
        ['/a/a', '/a/b', '/a/c' ].map |$r| {
          nodes_from(MyRes[$r]).map |$n| { $n.resources.keys }.flatten
        } +
        ['/b/a', '/b/b', '/b/c' ].map |$r| {
          nodes_to(MyRes[$r]).map |$n| { $n.resources.keys }.flatten
        }
        |-SRC
      Evaluates_to([
        ['myres[/b/a]', 'myres[/b/b]', 'myres[/b/c]'],
        ['myres[/b/a]', 'myres[/b/b]', 'myres[/b/c]'],
        ['myres[/b/a]', 'myres[/b/b]', 'myres[/b/c]'],
        ['myres[/a/a]', 'myres[/a/b]', 'myres[/a/c]'],
        ['myres[/a/a]', 'myres[/a/b]', 'myres[/a/c]'],
        ['myres[/a/a]', 'myres[/a/b]', 'myres[/a/c]'],
        ])),

    Example('resources can be obtained from $pnr"',
      Given(Format(@(SRC), Get('resourceType'))),
        %s
        myres { '/a/a': ensure => present } ->
        with || {
          $r2 = myres { '/b/a': ensure => $pnr[Myres['/a/a']].value.ensure }
          $r2[0].ensure
        }
        |-SRC
      Evaluates_to('present')),

    Example('current resources are not available through $pnr',
      Given(Format(@(SRC), Get('resourceType'))),
        %s
        myres { '/a/a': } ->
        with || {
          myres { '/b/a': }
          $pnr[Myres['/b/a']]
        }
        |-SRC
      Evaluates_to(undef)),
  ),

  Examples('when referenced',
    Example('can be referenced with parameters',
      Given(Format("%s\nString(MyRes['/foo/bar'])", Get('resourceType'))),
      Evaluates_to(`MyRes['/foo/bar']`)),

    Example('instance be retrieved using a type reference',
      Given(Format(@(SRC), Get('resourceType'))),
        %s
        myres { '/foo/bar': }
        String(get_resource(MyRes['/foo/bar']))
        |-SRC
      Evaluates_to(`MyRes('title' => '/foo/bar')`)),
  ),

  Examples(`built-in`,
    Example(`can instantiate`,
      Given(Format(@(SRC))),
        file { '/foo/bar': ensure => present }
        String(get_resource(File['/foo/bar']))
        |-SRC
      Evaluates_to(`File('title' => '/foo/bar', 'values' => {'ensure' => 'present'})`)),
  ),
)
